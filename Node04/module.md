## 什么是模块化
在平时开发中遇到做令人头疼的是什么？
- 命名冲突
- 繁琐的文件依赖
在历史上，js一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方式拼装起来。而其他语言就有。
所以在js中，上面两个问题是在开发过程中最令人头痛的问题。那么什么是模块系统？
从现实角度（手机里面的零件、电脑、活动板房）
- 生产效率高
- 可维护性高
程序角度讲（就是把一个文件中的代码拆分到不同的小文件中，每个小文件就称为一个模块，例如jQuery源码，把每个功能分开写在一个js文件中）
- 开发效率高
- 可维护性好（哪个功能出问题，直接去修改该模块就好）
  
Node中，模块具有哪些特性来满足我们使用，让我们用起来得心应手
- 模块作用域
    - 好处就是不需要去考虑全局命名空间冲突的问题
-  模块通信规则
    - 所有模块如果都是封闭的自然不行，如果要访问其他的模块的成员时候，就要遵循一定的模块通信规则,说白了就是输入和输出

## 模块通信规则
### require模块引入
```
//引入Node中的核心模块fs
var fs = require('fs');

//第三方模块的引入
//npm install marked 
//注意：此时你引入的模块名就是你下载包的名字
var marked = require('marked');

//引入用户自己写的模块
var foo = require('./foo.js');
```
## Node中模块加载机制
### 什么是module path
对于每一个require的文件模块。创建这个模块对象的时候，这个模块便会有一个paths属性，是Node根据当前文件路径计算得到的。
### 怎么加载
#### 绝对路径加载
如果require的是一个绝对路径的文件，查找时，是不会遍历每一个node_modules目录。流程如下:
    1.从module path 数组中取出第一个目录作为查找基准。
    2.直接进入目录中查找该文件，如果存在，结束查找。不存在就往下查找。
    3.尝试添加.js,.json,.node后缀名查找，如果存在，结束查找，如果不存在继续往下查找。
    4.尝试将require的参数作为一个包来进行查找，读取目录下的packge.json文件，获取到main参数的指定的入口文件。
    5.如果以上都失败，则读取module path数组中下一个目录为基准去查找，循环上面的步骤。如果存在，就结束查找，不存在就继续查找，知道module path中的最后一个值。
    6.如果仍然失败，就会抛出异常。
整个查找过程类似于js原型链和作用域的查找。所幸Node对路径查找，实现了缓存机制，也就是每次加载模块之前都会先去内存查找。否则每次判断路劲都是同步阻塞式进行，会严重导致性能消耗。

如果require的是一个文件名字，那么Node会优先判断是不是核心模块，如果是核心模块，就直接加载;如果不是就会遵循以下方式加载。
    1.Node会去Node_modules目录中找，找到引用的模块名目录，在该目录下找到package.json文件。
    2.如果找到pacakage.json文件，则找到该文件中的main属性，拿到main属性指定的入口文件。
    3.如果没有找到，Node就会去上一级目录下找node_modules目录,规则同上......
    4.如果一直都找不到，那就报错。
注意：第三方模块都是npm install 命令下载的，此时会在当前Node运行的目录中生成一个node_modules目录。